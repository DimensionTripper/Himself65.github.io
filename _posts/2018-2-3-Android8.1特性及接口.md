---
layout: post
title: "Android8.1特性及接口"
subtitle: "新翻译一小段"
date: 2018-2-5 1:00:00
author: "Android团队"
header-img: "img/head_post/2018-02-03-01.png"
darktheme: true
tags: 
    - 转载
    - 翻译
    - 英语学习
---
# Android8.1特性及接口

[原文地址](https://developer.android.com/about/versions/oreo/android-8.1.html)

## Android Oreo (Go 版本)

我们在Android Go中开始去优化世界各地安卓用户的上网体验。从Android8.1开始，我们正使安卓作为入门级设备的一个强大平台。在未来的Android Oreo (Go edition)版本中我们会加入：

- **内存优化**。提升了内存使用效率，让App能在1GB或更少内存下有效率运行

- **灵活化的目标选项**。新的硬件常量，使你更好的分配你的App通过Google Play在设备内存正常或低内存状态下

- **Google Play**。所有App都能在Android Oreo (Go edition)上运行。Google Play会提升专门优化过的App可见性，这样给数十亿人绝佳的用户体验，并给开发者提供丰富的用户体验指导方案

我们已经更新了用户体验指导方案在 如何在新Android上优化您App的运存。对于大多数开发者而言，优化你现在的Apk或者是使用谷歌商店的多元化Apk特性来针对你Apk在低内存状态下的最好的办法就是去装一个Android Oreo

---

以下内容只翻译了标题

## 神经网络API

神经网络API给在设备上的学习框架比如TensorFlow Lite（Google的跨平台手机ML库、Caffe2等） 提供了加速计算和逻辑推理功能。访问TensorFlow Lite开源库来下载和查找文献。TensorFlow Lite与Neural网络API合作来在你手机上更有效率的跑一些像Mob lieNet、Inception v3、Smart Reply等模型。

## 自动填充框架更新

Android 8.1 (API level 27) provides several improvements to the Autofill Framework that you can incorporate into your apps.

The BaseAdapter class now includes the setAutofillOptions() method, which allows you to provide string representations of the values in an adapter. This is useful for spinner controls that dynamically generate the values in their adapters. For example, you can use the setAutofillOptions() method to provide a string representation of the list of years that the users can choose as part of a credit card expiration date. Autofill services can use the string representation to appropriately fill out the views that require the data.

Additionally, the AutofillManager class includes the notifyViewVisibilityChanged(View, int, boolean) method that you can call to notify the framework about changes in the visibility of a view in a virtual structure. There's also an overload of the method for non virtual structures. However, non virtual structures usually don't require you to explicitly notify the framework because the method is already called by the View class.

Android 8.1 also gives Autofill Services more ability to customize the save UI affordance by adding support for CustomDescription and Validator within SaveInfo.

Custom descriptions are useful to help the autofill service clarify what is being saved; for example, when the screen contains a credit card, it could display a logo of the credit card bank, the last four digits of the credit card number, and its expiration number. To learn more, see the CustomDescription class.

Validator objects are used to avoid displaying the autofill save UI when the Validator condition isn't satisfied. To learn more, see the Validator class along with its subclasses, LuhnChecksumValidator and RegexValidator.

## 消息通知

Android 8.1 includes the following changes to notifications:

- Apps can now only make a notification alert sound once per second. Alert sounds that exceed this rate aren't queued and are lost. This change doesn't affect other aspects of notification behavior and notification messages still post as expected.

- NotificationListenerService and ConditionProviderService are not supported on low-RAM Android-powered devices that return true when ActivityManager.isLowRamDevice() is called.

## 富文本编辑更新

Beginning with API level 27, the EditText.getText() method returns an Editable; previously it returned a CharSequence. This change is backward-compatible, as Editable implements CharSequence.

The Editable interface provides valuable additional functionality. For example, because Editable also implements the Spannable interface, you can apply markup to content within an instance of EditText.

## 程序化的安全浏览网站操作

By using the WebView implementation of the Safe Browsing API, your app can detect when an instance of WebView attempts to navigate to a URL that Google has classified as a known threat. By default, the WebView shows an interstitial that warns users of the known threat. This screen gives users the option to load the URL anyway or return to a previous page that's safe.

In Android 8.1, you can define programmatically how your app responds to a known threat:

- You can control whether your app reports known threats to Safe Browsing.

- You can have your app automatically perform a particular action—such as going back to safety—each time it encounters a URL that Safe Browsing classifies as a known threat.

> Note: For optimal protection against known threats, wait until you've initialized Safe Browsing before you invoke a WebView object's loadUrl() method.

The following code snippets show how you can instruct your app's instances of WebView to always go back to safety after encountering a known threat:

> AndroidManifest.xml

``` xml
<manifest>
    <application>
        ...
        <meta-data android:name="android.webkit.WebView.EnableSafeBrowsing"
                   android:value="true" />
    </application>
</manifest>
```

> MyWebActivity.java

``` java
private WebView mSuperSafeWebView;
private boolean mSafeBrowsingIsInitialized;

// ...

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    mSuperSafeWebView = new WebView(this);
    mSuperSafeWebView.setWebViewClient(new MyWebViewClient());
    mSafeBrowsingIsInitialized = false;

    mSuperSafeWebView.startSafeBrowsing(this, new ValueCallback<Boolean>() {
        @Override
        public void onReceiveValue(Boolean success) {
            mSafeBrowsingIsInitialized = true;
            if (!success) {
                Log.e("MY_APP_TAG", "Unable to initialize Safe Browsing!");
            }
        }
    });
}
```

> MyWebViewClient.java

``` java
public class MyWebViewClient extends WebViewClient {
    // Automatically go "back to safety" when attempting to load a website that
    // Safe Browsing has identified as a known threat. An instance of WebView
    // calls this method only after Safe Browsing is initialized, so there's no
    // conditional logic needed here.
    @Override
    public void onSafeBrowsingHit(WebView view, WebResourceRequest request,
            int threatType, SafeBrowsingResponse callback) {
        // The "true" argument indicates that your app reports incidents like
        // this one to Safe Browsing.
        callback.backToSafety(true);
        Toast.makeText(view.getContext(), "Unsafe web page blocked.",
                Toast.LENGTH_LONG).show();
    }
}
```

## 视频缩略图提取

The MediaMetadataRetriever class has a new method, getScaledFrameAtTime(), that finds a frame near a given time position and returns a bitmap with the same aspect ratio as the source frame, but scaled to fit into a rectangle of given width and height. This is useful for generating thumbnail images from video.

We recommend using this method rather than getFrameAtTime() which can waste memory because it returns a bitmap with the same resolution as the source video. For example, a frame from a 4K video would be a 16MB bitmap, far larger than you would need for a thumbnail image.

## 内存共享接口

Android 8.1 (API level 27) introduces a new SharedMemory API. This class allows you to create, map, and manage an anonymous SharedMemory instance. You set the memory protection on a SharedMemory object for reading and/or writing, and, since the SharedMemory object is Parcelable, you can easily pass it to another process through AIDL.

The SharedMemory API interoperates with the ASharedMemory facility in the NDK. ASharedMemory gives access to a file descriptor, which can then be mapped to read and write. It's a great way to share large amounts of data between apps or between multiple processes within a single app.

## 墙纸颜色接口

Android 8.1 (API level 27) allows your live wallpaper to provide color information to the system UI. You do this by creating a WallpaperColors object from a bitmap, a drawable, or by using three manually-selected colors. You can also retrieve this color information.

To create a WallpaperColors object, do either of the following:

To create a WallpaperColors object by using three colors, create an instance of the WallpaperColors class by passing the primary, the secondary, and the tertiary color. The primary color must not be null.

- To create a WallpaperColors object from a bitmap, call the fromBitmap() method by passing the bitmap source as parameter.

- To create a WallpaperColors object from a drawable, call the fromDrawable() method by passing the drawable source as parameter.

- To retrieve the primary, secondary, or tertiary color details from the wallpaper, call the following methods:

--- 

- getPrimaryColor() returns the most visually-representativecolor of the wallpaper.

- getSecondaryColor() returns the second most preeminent color of the wallpaper.

- getTertiaryColor() method returns the third most preeminent color of the wallpaper.

To notify the system about any significant color changes in your live wallpaper, call the notifyColorsChanged() method. This method triggers an onComputeColors() lifecycle event where you have an opportunity to provide a new WallpaperColors object.

To add a listener for color changes, you can call the addOnColorsChangedListener() method. You can also call the getWallpaperColors() method to retrieve the primary colors of a wallpaper.

## 指纹升级

The FingerprintManager class has introduced the following error codes:

- FINGERPRINT_ERROR_LOCKOUT_PERMANENT – The user has tried too many times to unlock their device using the fingerprint reader.

- FINGERPRINT_ERROR_VENDOR – A vendor-specific fingerprint reader error occurred.

## 加密升级

A number of cryptography changes have been made with Android 8.1:

- New algorithms have been implemented in Conscrypt. The Conscrypt implementation is preferentially used over the existing Bouncy Castle implementation. New algorithms include:
- - AlgorithmParameters:GCM

- - KeyGenerator:AES

- - KeyGenerator:DESEDE

- - KeyGenerator:HMACMD5

- - KeyGenerator:HMACSHA1

- - KeyGenerator:HMACSHA224

- - KeyGenerator:HMACSHA256

- - KeyGenerator:HMACSHA384

- - KeyGenerator:HMACSHA512

- - SecretKeyFactory:DESEDE

- - Signature:NONEWITHECDSA

- Cipher.getParameters().getParameterSpec(IvParameterSpec.class) no longer works for algorithms that use GCM. Instead, use getParameterSpec(GCMParameterSpec.class).

- Many internal Conscrypt classes associated with TLS were refactored. Since developers sometimes access these reflectively, shims have been left in place to support previous usage, but some details have changed. For example, sockets previously were of type OpenSSLSocketImpl, but now they’re of type ConscryptFileDescriptorSocket or ConscryptEngineSocket, both of which extend OpenSSLSocketImpl.

- SSLSession methods used to throw IllegalArgumentException when passed a null reference, they now throw NullPointerException.

- The RSA KeyFactory no longer allows generation of keys from byte arrays that are larger than the encoded key. Calls to generatePrivate() and generatePublic() that provide a KeySpec where the key structure does not fill the entire buffer will result in an InvalidKeySpecException.

- When a socket read is interrupted by the socket being closed, Conscrypt used to return -1 from the read. The read now throws SocketException.

- The set of root CA certificates has been changed, mostly removing a large number of obsolete certificates, but also removing the root certificates for WoSign and StartCom. For more information on this decision, see the Google Security Blog post, Final removal of trust in WoSign and StartCom Certificates.